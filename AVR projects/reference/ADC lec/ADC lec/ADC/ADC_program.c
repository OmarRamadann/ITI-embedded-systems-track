/*
 * ADC_program.c
 *
 *  Created on: Nov 22, 2022
 *      Author: abdullah
 */

#include"ADC_interface.h"
#include"ADC_pcfg.h"
#include"ADC_private.h"
#include"../../SERVICES/BIT_math.h"
#include"../../SERVICES/STD_TYPES.h"
void (*ptr_fn)(void)=NULL;
void ADC_voidInit(void)
{
#if ADC_VREF ==ADC_VREF_256V
SET_BIT(ADMUX,6);
SET_BIT(ADMUX,7);
#elif ADC_VREF ==ADC_VREF_AVCC
SET_BIT(ADMUX,6);
CLR_BIT(ADMUX,7);
#elif ADC_VREF ==ADC_VREF_AREF
CLR_BIT(ADMUX,6);
CLR_BIT(ADMUX,7);
#endif

#if ADC_ADJUSTMENT==ADC_LEFT_ADJUSTMENT
SET_BIT(ADMUX,5);
#elif ADC_ADJUSTMENT==ADC_RIGHT_ADJUSTMENT
CLR_BIT(ADMUX,5);
#endif

#if ADC_MODE ==ADC_SINGLE_ENDED  && ADC_PIN==ADC0
CLR_BIT(ADMUX,0);
CLR_BIT(ADMUX,1);
CLR_BIT(ADMUX,2);
CLR_BIT(ADMUX,3);
CLR_BIT(ADMUX,4);
#elif  ADC_MODE ==ADC_SINGLE_ENDED  && ADC_PIN==ADC1
SET_BIT(ADMUX,0);
CLR_BIT(ADMUX,1);
CLR_BIT(ADMUX,2);
CLR_BIT(ADMUX,3);
CLR_BIT(ADMUX,4);
#elif  ADC_MODE ==ADC_SINGLE_ENDED  && ADC_PIN==ADC2

CLR_BIT(ADMUX,0);
SET_BIT(ADMUX,1);
CLR_BIT(ADMUX,2);
CLR_BIT(ADMUX,3);
CLR_BIT(ADMUX,4);
#elif  ADC_MODE ==ADC_SINGLE_ENDED  && ADC_PIN==ADC3
SET_BIT(ADMUX,0);
SET_BIT(ADMUX,1);
CLR_BIT(ADMUX,2);
CLR_BIT(ADMUX,3);
CLR_BIT(ADMUX,4);
#elif  ADC_MODE ==ADC_SINGLE_ENDED  && ADC_PIN==ADC4

CLR_BIT(ADMUX,0);
CLR_BIT(ADMUX,1);
SET_BIT(ADMUX,2);
CLR_BIT(ADMUX,3);
CLR_BIT(ADMUX,4);
#elif  ADC_MODE ==ADC_SINGLE_ENDED  && ADC_PIN==ADC5
SET_BIT(ADMUX,0);
CLR_BIT(ADMUX,1);
SET_BIT(ADMUX,2);
CLR_BIT(ADMUX,3);
CLR_BIT(ADMUX,4);
#elif  ADC_MODE ==ADC_SINGLE_ENDED  && ADC_PIN==ADC6
CLR_BIT(ADMUX,0);
SET_BIT(ADMUX,1);
SET_BIT(ADMUX,2);
CLR_BIT(ADMUX,3);
CLR_BIT(ADMUX,4);
#elif  ADC_MODE ==ADC_SINGLE_ENDED  && ADC_PIN==ADC7

SET_BIT(ADMUX,0);
SET_BIT(ADMUX,1);
SET_BIT(ADMUX,2);
CLR_BIT(ADMUX,3);
CLR_BIT(ADMUX,4);
#elif  ADC_MODE ==ADC_DIFFRENTIAL  && ADC_PIN==ADC0 /*all are subtracted fromADC1 WITH GAIN*1*/
CLR_BIT(ADMUX,0);
CLR_BIT(ADMUX,1);
CLR_BIT(ADMUX,2);
CLR_BIT(ADMUX,3);
SET_BIT(ADMUX,4);
#elif  ADC_MODE ==ADC_DIFFRENTIAL  && ADC_PIN==ADC2 /*all are subtracted fromADC1 WITH GAIN*1*/
CLR_BIT(ADMUX,0);
SET_BIT(ADMUX,1);
CLR_BIT(ADMUX,2);
CLR_BIT(ADMUX,3);
SET_BIT(ADMUX,4);
#elif  ADC_MODE ==ADC_DIFFRENTIAL  && ADC_PIN==ADC3 /*all are subtracted fromADC1 WITH GAIN*1*/
SET_BIT(ADMUX,0);
SET_BIT(ADMUX,1);
CLR_BIT(ADMUX,2);
CLR_BIT(ADMUX,3);
SET_BIT(ADMUX,4);
#elif  ADC_MODE ==ADC_DIFFRENTIAL  && ADC_PIN==ADC4 /*all are subtracted fromADC1 WITH GAIN*1*/
CLR_BIT(ADMUX,0);
CLR_BIT(ADMUX,1);
SET_BIT(ADMUX,2);
CLR_BIT(ADMUX,3);
SET_BIT(ADMUX,4);
#elif  ADC_MODE ==ADC_DIFFRENTIAL  && ADC_PIN==ADC5 /*all are subtracted fromADC1 WITH GAIN*1*/

SET_BIT(ADMUX,0);
CLR_BIT(ADMUX,1);
SET_BIT(ADMUX,2);
CLR_BIT(ADMUX,3);
SET_BIT(ADMUX,4);
#elif  ADC_MODE ==ADC_DIFFRENTIAL  && ADC_PIN==ADC6 /*all are subtracted fromADC1 WITH GAIN*1*/
CLR_BIT(ADMUX,0);
SET_BIT(ADMUX,1);
SET_BIT(ADMUX,2);
CLR_BIT(ADMUX,3);
SET_BIT(ADMUX,4);
#elif  ADC_MODE ==ADC_DIFFRENTIAL  && ADC_PIN==ADC7 /*all are subtracted fromADC1 WITH GAIN*1*/
SET_BIT(ADMUX,0);
SET_BIT(ADMUX,1);
SET_BIT(ADMUX,2);
CLR_BIT(ADMUX,3);
SET_BIT(ADMUX,4);

#endif
SET_BIT(ADCSRA,7);//enable ADC
SET_BIT(ADCSRA,6);//STRAT CONVERSION
#if ADC_TYPE == INTERRUPT
SET_BIT(ADCSRA,3);//PIE enable
SET_BIT(SREG,7);//GIE enable
#endif
#if ADC_PRESCALER==2
CLR_BIT(ADCSRA,0);
CLR_BIT(ADCSRA,1);
CLR_BIT(ADCSRA,2);
#elif ADC_PRESCALER==4
CLR_BIT(ADCSRA,0);
SET_BIT(ADCSRA,1);
CLR_BIT(ADCSRA,2);
#elif ADC_PRESCALER==8
SET_BIT(ADCSRA,0);
SET_BIT(ADCSRA,1);
CLR_BIT(ADCSRA,2);
#elif ADC_PRESCALER==16
CLR_BIT(ADCSRA,0);
CLR_BIT(ADCSRA,1);
SET_BIT(ADCSRA,2);
#elif ADC_PRESCALER==32
SET_BIT(ADCSRA,0);
CLR_BIT(ADCSRA,1);
SET_BIT(ADCSRA,2);
#elif ADC_PRESCALER==64
CLR_BIT(ADCSRA,0);
SET_BIT(ADCSRA,1);
SET_BIT(ADCSRA,2);
#elif ADC_PRESCALER==128
SET_BIT(ADCSRA,0);
SET_BIT(ADCSRA,1);
SET_BIT(ADCSRA,2);
#endif


#if ADC_CONVERSION_MODE ==ADC_FREE_RUNNING
CLR_BIT(SFIOR,5);
CLR_BIT(SFIOR,6);
CLR_BIT(SFIOR,7);
#endif
}
u16 ADC_u16getSTEPS(void)
{

	while(ADC_u8CheckFLAG()==0);

#if ADC_ADJUSTMENT==ADC_RIGHT_ADJUSTMENT
ADC_voidClearFlag();
   #if ADC_CONVERSION_MODE==ADC_SINGLE_COVERSION
	ADC_voidStartConversion();
#endif
	return ADCL+(ADCH<<8);
#elif ADC_ADJUSTMENT==ADC_LEFT_ADJUSTMENT
	ADC_voidClearFlag();
   #if ADC_CONVERSION_MODE==ADC_SINGLE_COVERSION
	ADC_voidStartConversion();
#endif
	return (ADCH<<2);
#endif


}

void ADC_voidDisable(void)
{

	CLR_BIT(ADCSRA,7);

}
void ADC_voidStartConversion(void)
{


	SET_BIT(ADCSRA,6);

}
#if ADC_TYPE ==POLLING
u8 ADC_u8CheckFLAG(void)
{
	u8 flag=GET_BIT(ADCSRA,4);
	return flag;


}
void ADC_voidClearFlag(void)
{
	SET_BIT(ADCSRA,4);
	                              // by writing 1
}
#endif
#if ADC_TYPE==INTERRUPT
void ADC_voidSetCallBackFN(void(*ptr_func)(void))
{

ptr_fn=ptr_func;


}
void __vector_16(void)__attribute__((signal));
void __vector_16(void)
{


	if(ptr_fn!=NULL)
	{

		ptr_fn();
	}
}


#endif
